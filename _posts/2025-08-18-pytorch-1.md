---
title: "Pytorch Basic Part 1 - סיווג תמונות בסיסי"
date: 2025-08-18
categories: pytorch,compute vision
---

# 🖼️ סיווג תמונות בסיסי עם PyTorch

בפוסט הזה נתחיל את המסע שלנו בעולם **ראייה ממוחשבת** עם PyTorch. נתמקד במשימה פשוטה יחסית אך מאוד שימושית: **סיווג בינארי** בין שתי קטגוריות – במקרה שלנו: **גבר** ו־**אשה**.

---

## 📌 איך זה עובד?

סיווג תמונות מתבצע על ידי **מודל למידת מכונה** שמקבל תמונה כקלט, מעבד אותה דרך רשת נוירונים (Neural Network) ולבסוף מחזיר הסתברות לכל מחלקה. המודל "לומד" מתוך דוגמאות רבות על ידי תהליך שנקרא **אימון**:

1. נטען את התמונות מהתקיות (למשל `data/train/male`, `data/train/female`).
2. נעבד את התמונות כך שיהיו בגודל אחיד ויהפכו ל־Tensor.
3. נעביר את התמונות דרך רשת נוירונים פשוטה.
4. נחשב את הטעות (Loss) בין התשובה שחזה המודל לבין התשובה הנכונה.
5. נעדכן את המשקלים של הרשת כדי לשפר את התוצאות.
6. נחזור על התהליך בהרבה אפוקים (Epochs) עד שהמודל ישיג דיוק מספק.

---

## 🧑‍💻 דוגמת קוד מלאה

להלן דוגמה מלאה ב־PyTorch לאימון מודל פשוט לסיווג בינארי בין גבר לאשה. שימו לב – אנו לא משתמשים ב־ResNet או מודלים מוכנים מראש, אלא מגדירים רשת פשוטה משלנו.

```python
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader
from torchvision import datasets, transforms

# --- הגדרות בסיסיות ---
BATCH_SIZE = 32
IMG_SIZE = 64
EPOCHS = 10

# --- טרנספורמציות לטעינת התמונות ---
transform = transforms.Compose([
    transforms.Resize((IMG_SIZE, IMG_SIZE)),
    transforms.ToTensor(),
])

# --- טעינת דאטה ---
train_data = datasets.ImageFolder("data/train", transform=transform)
val_data = datasets.ImageFolder("data/val", transform=transform)

train_loader = DataLoader(train_data, batch_size=BATCH_SIZE, shuffle=True)
val_loader = DataLoader(val_data, batch_size=BATCH_SIZE)

# --- רשת נוירונים פשוטה ---
class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.conv_layer = nn.Sequential(
            nn.Conv2d(3, 16, kernel_size=3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),

            nn.Conv2d(16, 32, kernel_size=3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2)
        )
        self.fc_layer = nn.Sequential(
            nn.Linear(32 * (IMG_SIZE // 4) * (IMG_SIZE // 4), 128),
            nn.ReLU(),
            nn.Linear(128, 1),
            nn.Sigmoid()
        )

    def forward(self, x):
        x = self.conv_layer(x)
        x = x.view(x.size(0), -1)
        x = self.fc_layer(x)
        return x

# --- יצירת המודל ---
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = SimpleCNN().to(device)

criterion = nn.BCELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# --- אימון ---
for epoch in range(EPOCHS):
    model.train()
    running_loss = 0.0
    for images, labels in train_loader:
        images, labels = images.to(device), labels.to(device).float().unsqueeze(1)

        optimizer.zero_grad()
        outputs = model(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()

    print(f"Epoch [{epoch+1}/{EPOCHS}], Loss: {running_loss/len(train_loader):.4f}")

# --- בדיקה על דאטה ולידציה ---
model.eval()
correct, total = 0, 0
with torch.no_grad():
    for images, labels in val_loader:
        images, labels = images.to(device), labels.to(device).float().unsqueeze(1)
        outputs = model(images)
        predicted = (outputs > 0.5).float()
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

print(f"Accuracy on validation set: {100 * correct / total:.2f}%")
```

---

## 🚀 סיכום

בפוסט הזה ראינו כיצד לבנות מודל בסיסי לסיווג תמונות בינארי באמצעות PyTorch – ללא שימוש במודלים מוכנים מראש. למדנו כיצד לטעון את הדאטה, להגדיר רשת פשוטה, לבצע אימון ולבדוק את הביצועים.

בפוסטים הבאים נעמיק ונכיר שיטות מתקדמות יותר לשיפור הדיוק והביצועים, כולל שימוש במודלים מוכנים מראש (Pretrained Models) כמו ResNet.
